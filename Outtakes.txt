## Restoring the values of raw pixels (highlights demosaicking pitfalls)
#for n in range(3):
#    rgb[BayerFilter[..., n] != 0, n] = raw[BayerFilter[..., n] != 0, n]


# An interpolation routine Λ: f(n) ➞ f(x) using ϕ, ψ or Π, or an "ad hoc"
#									 lambda x: 3/4*(abs(x) < 1)*(1 - x**2)

## De-PIL-led version
#def pix_diff(ip, iq, mn):
#	rgb_pq = [abs(c - d) for (c, d) in zip(ip.getpixel(mn), iq.getpixel(mn))]
#	return tuple(rgb_pq)
#Image difference computation
#M, N = ip.size; i = Image.new('RGB', (M, N));
#for m in range(M):
#	for n in range(N):
#	   i.putpixel((m, n), pix_diff(ip, iq, (m, n))) 



	#nx, ny = [], []
	#grid = w/c
	#for n in range(c):
	#	for m in range(c >> 1):
	#		#print(n, m)
	#		nx += [grid/2 + n * grid]
	#		ny += [grid/2 + m * grid]
	#grid /= 2
	#for n in range(c):
	#	for m in range(c >> 1, c):
	#		#print(n, m)
	#		nx += [grid/2 + n * grid]
	#		ny += [grid/2 + m * grid]
	#c *= c


	## The Lp agnostic 1-NN algorithm illustration
# 1. Generate N random sites
# 2. Create the Voronoi's diagram for lp, 0 < p ≤ 2
# 3. Create a grid N(N - 1) for the generated N random sites
# 4. Associate the new N(N - 1) sites to the classes accordingly to the diagram for the selected lp
# 5. Generate o Voronoi diagram (for arbitrary p <= 2) for these N² sites

# REMARK: In order to improve approximation quality one can add a new (set of) 
#         site(s) in the arbitrary position(s), together with the accompanying grid points.


from PIL import Image
from random import randrange as RR, seed
from sys import argv
from numpy import arange

def RA(l = 50, u = 201, s = 150): return 3 * [RR(l, u, s)]
def distance(x, y, p):
	return pow(pow(abs(x), p) + pow(abs(y), p), 1.0/p) if (p > 0.0) else max(abs(x), abs(y)) # special case 'lmax'

def generate_voronoi_diagram(w = 0x100, h = 0x100, c = 0x8, p = 2.0, sd = 0x29):
	seed(sd) # Controlled randomness to get the same points for various p
	image = Image.new("RGB", (w, h))
	
	# Just a standard random case...
	nx, ny = zip(*[[RR(6*w/8) + w/8, RR(6*h/8) + h/8] for _ in range(c)])
	# Black & white...
	nr, ng, nb = zip(*[RA(0, 255) for _ in range(c)])	

	##Drawing...
	img = image.load()
	# ... cells
	for y in range(h):
		for x in range(w):
			dmin = distance(w - 1, h - 1, p); j = -1
			for i in range(c):
				d = distance(nx[i] - x, ny[i] - y, p)
				if d < dmin:
					dmin = d; j = i
			img[x, y] = nr[j], ng[j], nb[j]
	# ... and sites
	px = (-3, -2, -1, 1, 2, 3)
	for dx in px:
		for dy in px:
			for i in range(c):
				img[nx[i] + dx, ny[i] + dy] = 0xff, 0, 0

	f = "./images/Voronoi-L{0}.png".format(p if p > 0.0 else 'max')
	image.save(f, 'PNG'); image.show()
	print("Voronoi's diagram saved to: {0}".format(f))
	return [nx, ny], [nr, ng, nb]

def lp_agnostic_Voronoi_diagram(NX, NY, r, g, b, p = 2.0, c = 0x8, sd = 0x29):
	# Generate N random points and N(N-1) additional ones that form a grid
	nx, ny = [], c*NY
	for n in range(c):
		nx += c*[NX[n]]		
	c *= c;

	f = './images/Voronoi-L{0}.png'.format(p if p > 0.0 else 'max')
	image = Image.open(f)
	(w, h) = image.size; print(w, h)
	img = image.load()
	nr, ng, nb = [], [], []
	for j in range(c):
		nr += [img[nx[j], ny[j]][0]] 
		ng += [img[nx[j], ny[j]][1]]
		nb += [img[nx[j], ny[j]][2]]
		print(nx[j], ny[j], img[nx[j], ny[j]][1])
	image.close()


	##Drawing...
	image = Image.new("RGB", (w, h))
	img = image.load()
	# ... cells
	for y in range(h):
		for x in range(w):
			dmin = distance(w - 1, h - 1, p); j = -1
			for i in range(c):
				d = distance(nx[i] - x, ny[i] - y, 0.5)
				if d < dmin:
					dmin = d; j = i
			img[x, y] = nr[j], ng[j], nb[j]
	# ... and sites
	px = (-3, -2, -1, 1, 2, 3)
	for dx in px:
		for dy in px:
			for i in range(c):
				img[nx[i] + dx, ny[i] + dy] = 0xff, 0, 0

	f = './images/Lp-agnostic-Voronoi.png'
	image.save(f, 'PNG'); image.show()
	print('Lp agnostic Voronoi''s diagram saved to: {0}'.format(f))


[x, y], [r, g, b] = generate_voronoi_diagram(p = 2.0, sd = 29, c = 0x10)
lp_agnostic_Voronoi_diagram(x, y, r, g, b, p = 2.0, c = 0x10)


################## Lp Agnostic Voronoi

## The Lp agnostic 1-NN algorithm illustration
# 1. Generate N random sites
# 2. Create the Voronoi's diagram for lp, 0 < p ≤ 2
# 3. Create a grid N(N - 1) for the generated N random sites
# 4. Associate the new N(N - 1) sites to the classes accordingly to the diagram for the selected lp
# 5. Generate o Voronoi diagram (for arbitrary p <= 2) for these N² sites

# REMARK: In order to improve approximation quality one can add a new (set of) 
#         site(s) in the arbitrary position(s), together with the accompanying grid points.


from PIL import Image
from random import randrange, seed
from sys import argv
from numpy import arange

def RA(l = 0x32, u = 0xd0, s = 0x96): return 3 * [randrange(l, u, s)]
def RR(l): return randrange(0xe*l/0x10) + l/0x10
def distance(x, y, p):
	return pow(pow(abs(x), p) + pow(abs(y), p), 1.0/p) if (p > 0.0) else max(abs(x), abs(y)) # special case 'lmax'

def lp_Voronoi_diagram(w = 0x100, h = 0x100, c = 0x8, p = 2.0, sd = 0x29):
	seed(sd) # Controlled randomness to get the same points for various p
	image = Image.new("RGB", (w, h))
	
	# Just a standard random case...
	nx, ny = zip(*[[RR(w), RR(h)] for _ in range(c)])
	# Black & white...
	nr, ng, nb = zip(*[RA(0, 0x100) for _ in range(c)])	

	##Drawing...
	img = image.load()
	# ... cells
	for y in range(h):
		for x in range(w):
			dmin = distance(w - 1, h - 1, p); j = -1
			for i in range(c):
				d = distance(nx[i] - x, ny[i] - y, p)
				if d < dmin:
					dmin = d; j = i
			img[x, y] = nr[j], ng[j], nb[j]

	f = './images/Voronoi-L{0}.png'.format(p)
	image.save(f, 'PNG')
	return nx, ny

def lp_agnostic_Voronoi_diagram(NX, NY, p = 2.0):
	# Generate N(N-1) additional sites to form an NxN grid
	c = len(NX)
	nx, ny = [], c*NY
	for n in range(c):
		nx += c*[NX[n]]		
	c *= len(NY);

	f = './images/Voronoi-L{0}.png'.format(p)
	image = Image.open(f)
	(w, h) = image.size
	img = image.load()
	nr, ng, nb = zip(*[img[nx[j], ny[j]] for j in range(c)])
	image.close()

	##Drawing...
	image = Image.new("RGB", (w, h))
	img = image.load()
	# ... cells
	for y in range(h):
		for x in range(w):
			dmin = distance(w - 1, h - 1, p); j = -1
			for i in range(c):
				d = distance(nx[i] - x, ny[i] - y, 0.5)
				if d < dmin:
					dmin = d; j = i
			img[x, y] = nr[j], ng[j], nb[j]
	
	# ... and sites
	px = [-1, 0, 1]; px = [0]
	for dx in px:
		for dy in px:
			for i in range(c):
				img[nx[i] + dx, ny[i] + dy] = 0xff, 0, 0

	f = './images/Lp-agnostic-Voronoi.png'
	image.save(f, 'PNG'); image.show()
	print('Lp agnostic Voronoi diagram saved to: {0}'.format(f))

	# Sites drawn at the original image
	f = './images/Voronoi-L{0}.png'.format(p if p > 0.0 else 'max')
	image = Image.open(f)
	(w, h) = image.size
	img = image.load()
	px = [-1, 0, 1]; px = [0]
	for dx in px:
		for dy in px:
			for i in range(len(NX)):
				img[NX[i] + dx, NY[i] + dy] = 0xff, 0, 0
	image.save(f, 'PNG'); image.show()
	print('Lp Voronoi diagram re-saved to: {0}'.format(f))

lp_agnostic_Voronoi_diagram(*lp_Voronoi_diagram(c = 0x20, sd = RR(0x1000)))



////////////////////// Cells@squares
## The Lp agnostic 1-NN algorithm illustration
# 1. Generate N random sites within a square
# 2. Create the Voronoi's diagram for lp, 0 < p ≤ 2 
# 3. Create a grid N(N - 1) for the generated N random sites
# 4. Associate the new N(N - 1) sites to the classes accordingly to the diagram for the selected lp
# 5. Generate o Voronoi diagram (for arbitrary p <= 2) for these N² sites

# REMARK: In order to improve approximation quality one can add a new (set of) 
#         site(s) in the arbitrary position(s), together with the accompanying grid points.

import time
from PIL import Image
from random import randrange, seed
from sys import argv
from numpy import arange, sqrt

def RA(l = 0x32, u = 0xd0, s = 0x96): return 3 * [randrange(l, u, s)]
def RR(l): return randrange(0x1e*l/0x20) + l/0x20

def distanceLp(x, y, p):
	return pow(pow(abs(x), p) + pow(abs(y), p), 1.0/p)

def lp_Voronoi_diagram(w = 0x80, c = 0x8, p = 2.0, sd = 0x29, show = False):
	seed(sd) # Controlled randomness to get the same points for various p
	image = Image.new("RGB", (w, w))
	
	# Just a standard random case...
	nx, ny = zip(*[[RR(w), RR(w)] for _ in range(c)])
	# Black & white...
	nr, ng, nb = zip(*[RA(0, 0x100) for _ in range(c)])	

	##Drawing...
	img = image.load()
	# ... cells
	for y in range(w):
		for x in range(w):
			dmin = distanceLp(w - 1, w - 1, p); j = -1
			for i in range(c):
				d = distanceLp(nx[i] - x, ny[i] - y, p)
				if d < dmin:
					dmin = d; j = i
			img[x, y] = nr[j], ng[j], nb[j]
	if(show):
		px = [-1, 0, 1]
		for dx in px:
			for dy in px:
				for i in range(c):
					img[nx[i] + dx, ny[i] + dy] = 0xff, 0, 0
		#image.show()
	f = './images/Voronoi-L{0}@{1}.png'.format(p, sd)
	image.save(f, 'PNG')
	return nx, ny

def lp_agnostic_Voronoi_diagram(NX, NY, p = 2.0):
	# Generate N(N-1) additional sites to form an NxN grid
	c = len(NX); nx, ny = [], c*NY
	for n in range(c):
		nx += c*[NX[n]]		
	c *= len(NY);

	f = './images/Voronoi-L{0}@{1}.png'.format(p, sd)
	image = Image.open(f); img = image.load()
	w = image.size[0]
	nr, ng, nb = zip(*[img[nx[j], ny[j]] for j in range(c)])
	image.close()

	##Drawing...
	image = Image.new("RGB", (w, w))
	img = image.load()
	# ... cells
	for y in range(w):
		for x in range(w):
			dmin = distanceLp(w - 1, w - 1, p); j = -1
			for i in range(c):
				d = distanceLp(nx[i] - x, ny[i] - y, p)
				if d < dmin:
					dmin = d; j = i
			img[x, y] = nr[j], ng[j], nb[j]
	
	px = [-1, 0, 1]
	for dx in px:
		for dy in px:
			for i in range(len(NX)): # N original points
				img[NX[i] + dx, NY[i] + dy] = 0xff, 0, 0
	# ... and N(N - 1) extra sites
	#px = [0]
	#for dx in px:
	#	for dy in px:
	#		for i in range(c): 
	#			img[nx[i] + dx, ny[i] + dy] = 0xff, 0xff, 0xff

	f = './images/Lp-agnostic-Voronoi@{0}.png'.format(sd)
	image.save(f, 'PNG'); #image.show()
	print('Lp agnostic Voronoi diagram saved to: {0}'.format(f))

	# Sites drawn at the original image
	f = './images/Voronoi-L{0}@{1}.png'.format(p, sd)
	image = Image.open(f); img = image.load()
	px = [-1, 0, 1]
	for dx in px:
		for dy in px:
			for i in range(len(NX)):
				img[NX[i] + dx, NY[i] + dy] = 0xff, 0, 0
	image.save(f, 'PNG'); #image.show()
	print('Lp Voronoi diagram re-saved to: {0}'.format(f))

## Show time off!
start = time.time()
sd, c = round(RR(0x1000)), 0x11
lp_agnostic_Voronoi_diagram(*lp_Voronoi_diagram(c = c, sd = sd))
_  = lp_Voronoi_diagram(c = c, sd = sd, p = 0.5, show = True)
print(round(time.time() - start))



///////////////////////////////// agnostic PhotoShop

## The Lp agnostic 1-NN algorithm illustration
# 1. Generate N random sites inside a square
# 2. Create the Voronoi's diagram for lp, 0 < p ≤ 2 (p = 2.0 is set by default)
# 3. Create a lattice of N(N - 1) sites for the generated N random ones
# 4. Associate the new N(N - 1) sites to the classes accordingly to the diagram for the selected lp
# 5. Generate o Voronoi diagram (for arbitrary p <= 2) for these NxN sites

# REMARK: In order to improve approximation quality one can add a new (set of) 
#         site(s) in the arbitrary position(s), together with the accompanying lattice points.

from time import time as TT
from PIL import Image, ImageMath
from random import randrange as RA, seed
from sys import argv
from numpy import arange

def RBW(l = 0x32, u = 0xd0, s = 0x96): return 3 * [RA(l, u, s)]
def RR(l): return RA(int(0x1e*l/0x20)) + int(l/0x20)
def distanceLp(x, y, p):
	return pow(pow(abs(x), p) + pow(abs(y), p), 1.0/p)

def lp_Voronoi_diagram(w = 0x100, c = 0x8, p = 2.0, sd = 0x29, show = False):
	seed(sd) # Controlled randomness to get the same points for various p
	image = Image.new("RGB", (w, w))
	
	# Just a standard random case...
	nx, ny = zip(*[[RR(w), RR(w)] for _ in range(c)])
	# Black & white...
	nr, ng, nb = zip(*[RBW(0, 0x100) for _ in range(c)])	

	##Drawing...
	img = image.load()
	# ... cells
	for y in range(w):
		for x in range(w):
			dmin = distanceLp(w - 1, w - 1, p); j = -1
			for i in range(c):
				d = distanceLp(nx[i] - x, ny[i] - y, p)
				if d < dmin:
					dmin = d; j = i
			img[x, y] = nr[j], ng[j], nb[j]
	## ... sites
	#px = [-1, 0, 1]
	#for dx in px:
	#	for dy in px:
	#		for i in range(c):
	#			img[nx[i] + dx, ny[i] + dy] = (0xff, 0x0, 0x0)

	f = './images/Voronoi-L{0}@{1}.png'.format(p, sd)
	image.save(f, 'PNG')
	return nx, ny

def lp_agnostic_Voronoi_diagram(NX, NY, w = 0x100, c = 0x8, p = 2.0):
	# Generate N(N-1) additional sites to form an NxN lattice
	# ... and extra sites as well
	c = len(NX); nx, ny = [], c*NY
	for n in range(c):
		nx += c*[NX[n]]		
	c *= len(NY);

	# Set sites' classes from the image
	f = './images/Voronoi-L{0}@{1}.png'.format(p, sd)
	image = Image.open(f); img = image.load()
	w = image.size[0]
	nr, ng, nb = zip(*[img[nx[j], ny[j]] for j in range(c)])
	image.close()
	
	## Drawing...
	image = Image.new("RGB", (w, w))
	img = image.load()
	# ... cells
	for y in range(w):
		for x in range(w):
			dmin = distanceLp(w - 1, w - 1, p); j = -1
			for i in range(c):
				d = distanceLp(nx[i] - x, ny[i] - y, p)
				if d < dmin:
					dmin = d; j = i
			img[x, y] = nr[j], ng[j], nb[j]

	f = './images/Lp-agnostic-Voronoi@{0}.png'.format(sd)
	image.save(f, 'PNG'); #image.show()
	print('Lp agnostic Voronoi diagram: {0}'.format(f))

	# ... and finally sites at the original image
	f = './images/Voronoi-L{0}@{1}.png'.format(p, sd)
	image = Image.open(f); img = image.load()

	image.save(f, 'PNG'); #image.show()
	print('Lp Voronoi diagram: {0}'.format(f))

def lp_improved_agnostic_Voronoi_diagram(NX, NY, w = 0x100, m = 0x1, c = 0x8, p = 2.0):
	## Generate extra sites for extra precision (in locations
	# where the classifications differ for Lp and for agnostic-Lp).
	ax, ay = [], []
	
	f = './images/Lp-agnostic-Voronoi-math-L{0}@{1}.png'.format(p, sd)
	image = Image.open(f); img = image.load()
	w = image.size[0]

	seed(TT())
	while(len(ax) < m * c):
		x, y = RR(w), RR(w)
		if(img[x, y] != (0x0, 0x0, 0x0)):
			ax += [x]
			ay += [y]
	image.close()
	NX += tuple(ax); NY += tuple(ay)
	
	# Generate N(N-1) additional sites to form an NxN lattice
	# ... and extra sites as well
	c = len(NX); nx, ny = [], c*NY
	for n in range(c):
		nx += c*[NX[n]]		
	c *= len(NY);

	# Set sites' classes from the image
	f = './images/Voronoi-L{0}@{1}.png'.format(p, sd)
	image = Image.open(f); img = image.load()
	w = image.size[0]
	nr, ng, nb = zip(*[img[nx[j], ny[j]] for j in range(c)])
	image.close()
	
	## Drawing...
	image = Image.new("RGB", (w, w))
	img = image.load()
	# ... cells
	for y in range(w):
		for x in range(w):
			dmin = distanceLp(w - 1, w - 1, p); j = -1
			for i in range(c):
				d = distanceLp(nx[i] - x, ny[i] - y, p)
				if d < dmin:
					dmin = d; j = i
			img[x, y] = nr[j], ng[j], nb[j]

	f = './images/Lp-improved-agnostic-Voronoi@{0}.png'.format(sd)
	image.save(f, 'PNG'); #image.show()
	## ... sites
	px = [-1, 0, 1]
	for dx in px:
		for dy in px:
			for i in range(len(NX)):
				img[NX[i] + dx, NY[i] + dy] = (0xff, 0x0, 0x0)
			for i in range(len(ax)):
				img[ax[i] + dx, ay[i] + dy] = (0xff, 0xff, 0xff)
	f = './images/Lp-improved-agnostic-Voronoi-sites@{0}.png'.format(sd)
	image.save(f, 'PNG'); #image.show()
	print('Lp improved agnostic Voronoi diagram: {0}'.format(f))

def lp_agnostic_Voronoi_diff(p = 2, sd = 0x29, improved = False):
	imp = 'improved-' if improved else ''
	fp, fa = './images/Voronoi-L{0}@{1}.png', './images/Lp-{0}agnostic-Voronoi@{1}.png'
	fav, fpv = Image.open(fa.format(imp, sd)), Image.open(fp.format(p, sd))
	fdv = Image.new('RGB', fpv.size)
	#ImageMath doesn't process RGB images (yet)...
	fdv = Image.merge('RGB', [ImageMath.eval('convert(abs(a - b), "L")', a = ipb, b = iqb) \
								for (ipb, iqb) in zip(fpv.split(), fav.split())])
	fdv.save('./images/Lp-{0}agnostic-Voronoi-diff-L{1}@{2}.png'.format(imp, p, sd), 'PNG')
	fpv.close(); fdv.close()

def lp_agnostic_Voronoi_ps(p = 2, sd = 0x29, improved = False, sites = False, opr = 'abs(a - b)'):
	imp, sts = 'improved-' if improved else '', '-sites' if sites else ''
	
	fa = './images/Lp-{0}agnostic-Voronoi{1}@{2}.png'
	fp = './images/Voronoi-L{0}@{1}.png'
	
	fav, fpv = Image.open(fa.format(imp, sts, sd)), Image.open(fp.format(p, sd))
	fdv = Image.new('RGB', fpv.size)
	#ImageMath doesn't process RGB images (yet)...
	fdv = Image.merge('RGB', [ImageMath.eval('convert({0}, "L")'.format(opr), a = ipb, b = iqb) \
								for (ipb, iqb) in zip(fpv.split(), fav.split())])
	f = './images/Lp-{0}agnostic-Voronoi-math-L{1}@{2}.png'
	fdv.save(f.format(imp, p, sd), 'PNG')
	fpv.close(); fdv.close()
	print('Lp agnostic Voronoi math: {0}'.format(f))

	
## Show time off!
start, ssd = TT(), int(RR(0x10000))
c, sd = (int(argv[1]), int(argv[2])) if len(argv) == 3 else (int(argv[1]), ssd) \
									 if len(argv) == 2 else (0x8, ssd) 
## Lp, with p as a reference and q as an illustration
p, q, w = 2.0, 0.5, 0x80

# The reference diagrams...
NXY = lp_Voronoi_diagram(w = w, c = c, sd = sd, p = p)
lp_agnostic_Voronoi_diagram(*NXY, w = w, p = p)
#lp_agnostic_Voronoi_diff(p = p, sd = sd)
lp_agnostic_Voronoi_ps(p = p, sd = sd)

# ... and their Lp-agnostic versions
lp_improved_agnostic_Voronoi_diagram(*NXY, w = w, c = c, p = p, m = 0x3)
#lp_agnostic_Voronoi_diff(p = p, sd = sd, improved = True)
lp_agnostic_Voronoi_ps(p = p, sd = sd, improved = True)
lp_agnostic_Voronoi_ps(p = p, sd = sd, improved = True, sites = True, opr = '(a + 2*b)/3')

# An illustration...
_   = lp_Voronoi_diagram(c = c, sd = sd, p = q)
# ... and a summary!
print('Elapsed time = {0}s'.format(round(TT() - start)))



////////////////// A struggle within

## The Lp agnostic 1-NN algorithm illustration
# 1. Generate N random sites inside a square
# 2. Create the Voronoi's diagram for lp, 0 < p ≤ 2 (p = 2.0 is set by default)
# 3. Create a lattice of N(N - 1) sites for the generated N random ones
# 4. Associate the new N(N - 1) sites to the classes accordingly to the diagram for the selected lp
# 5. Generate o Voronoi diagram (for arbitrary p <= 2) for these NxN sites

# REMARK: In order to improve approximation quality one can add a new (set of) 
#         site(s) in the arbitrary position(s), together with the accompanying lattice points.

from time import time as TT
from PIL import Image, ImageMath
from random import randrange as RA, seed
from sys import argv
from numpy import arange

def RBW(l = 0x32, u = 0xd0, s = 0x96): return 3 * [RA(l, u, s)]
def RR(l): return RA(int(0x1e*l/0x20)) + int(l/0x20)
def distanceLp(x, y, p):
	return pow(pow(abs(x), p) + pow(abs(y), p), 1.0/p)

def lp_Voronoi_diagram(w = 0x100, c = 0x8, p = 2.0, sd = 0x29, show = False):
	seed(sd) # Controlled randomness to get the same points for various p
	image = Image.new("RGB", (w, w))
	
	# Just a standard random case...
	nx, ny = zip(*[[RR(w), RR(w)] for _ in range(c)])
	# Black & white...
	nr, ng, nb = zip(*[RBW(0, 0x100) for _ in range(c)])	

	##Drawing...
	img = image.load()
	# ... cells
	for y in range(w):
		for x in range(w):
			dmin = distanceLp(w - 1, w - 1, p); j = -1
			for i in range(c):
				d = distanceLp(nx[i] - x, ny[i] - y, p)
				if d < dmin:
					dmin = d; j = i
			img[x, y] = nr[j], ng[j], nb[j]

	f = './images/Voronoi-L{0}@{1}.png'.format(p, sd)
	image.save(f, 'PNG')
	print('Lp Voronoi diagram: {0}'.format(f))

	return nx, ny

def lp_agnostic_Voronoi_diagram(NX, NY, w = 0x100, c = 0x8, p = 2.0):
	# Generate N(N-1) additional sites to form an NxN lattice
	# ... and extra sites as well
	c = len(NX); nx, ny = [], c*NY
	for n in range(c):
		nx += c*[NX[n]]		
	c *= len(NY);

	# Set sites' classes from the image
	f = './images/Voronoi-L{0}@{1}.png'.format(p, sd)
	image = Image.open(f); img = image.load()
	w = image.size[0]
	nr, ng, nb = zip(*[img[nx[j], ny[j]] for j in range(c)])
	image.close()
	
	## Drawing...
	image = Image.new("RGB", (w, w))
	img = image.load()
	# ... cells
	for y in range(w):
		for x in range(w):
			dmin = distanceLp(w - 1, w - 1, p); j = -1
			for i in range(c):
				d = distanceLp(nx[i] - x, ny[i] - y, p)
				if d < dmin:
					dmin = d; j = i
			img[x, y] = nr[j], ng[j], nb[j]

	f = './images/Lp-agnostic-Voronoi@{0}.png'.format(sd)
	image.save(f, 'PNG'); #image.show()
	print('Lp agnostic Voronoi diagram: {0}'.format(f))

def within(xy, xy_min, xy_max):
	return xy[0] > xy_min[0] and xy[0] < xy_max[0] \
	   and xy[1] > xy_min[1] and xy[1] < xy_max[1]

def lp_improved_agnostic_Voronoi_diagram(NX, NY, w = 0x100, m = 0x1, c = 0x8, p = 2.0):
	## Generate extra sites for extra precision (in locations
	# where the classifications differ for Lp and for agnostic-Lp).
	ax, ay = [], []
	
	f = './images/Lp-agnostic-Voronoi-math-L{0}@{1}.png'.format(p, sd)
	image = Image.open(f); img = image.load()
	w = image.size[0]

	#seed(TT())
	x_min, x_max = min(NX), max(NX)
	y_min, y_max = min(NY), max(NY)
	while(len(ax) < m * c):
		x, y = RR(w), RR(w)
		if(img[x, y] != (0x0, 0x0, 0x0) and within((x, y), (x_min, y_min), (x_max, y_max))):
			ax += [x]
			ay += [y]
	image.close()
	NX += tuple(ax); NY += tuple(ay)
	
	# Generate N(N-1) additional sites to form an NxN lattice
	# ... and extra sites as well
	c = len(NX); nx, ny = [], c*NY
	for n in range(c):
		nx += c*[NX[n]]		
	c *= len(NY);

	# Set sites' classes from the image
	f = './images/Voronoi-L{0}@{1}.png'.format(p, sd)
	image = Image.open(f); img = image.load()
	w = image.size[0]
	nr, ng, nb = zip(*[img[nx[j], ny[j]] for j in range(c)])
	image.close()
	
	## Drawing...
	image = Image.new("RGB", (w, w))
	img = image.load()
	# ... cells
	for y in range(w):
		for x in range(w):
			dmin = distanceLp(w - 1, w - 1, p); j = -1
			for i in range(c):
				d = distanceLp(nx[i] - x, ny[i] - y, p)
				if d < dmin:
					dmin = d; j = i
			img[x, y] = nr[j], ng[j], nb[j]

	f = './images/Lp-improved-agnostic-Voronoi@{0}.png'.format(sd)
	image.save(f, 'PNG'); #image.show()
	print('Lp improved agnostic Voronoi diagram: {0}'.format(f))
	## ... sites
	px = [-1, 0, 1]
	for dx in px:
		for dy in px:
			for i in range(len(NX)):
				img[NX[i] + dx, NY[i] + dy] = (0xff, 0x0, 0x0)
			for i in range(len(ax)):
				img[ax[i] + dx, ay[i] + dy] = (0xff, 0xff, 0xff)
	px = [0]
	for dx in px:
		for dy in px:
			for i in range(c):
				img[nx[i] + dx, ny[i] + dy] = (0xff, 0xff, 0x0)
	f = './images/Lp-improved-agnostic-Voronoi-sites@{0}.png'.format(sd)
	image.save(f, 'PNG'); #image.show()
	print('Lp improved agnostic Voronoi diagram with sites: {0}'.format(f))

def lp_agnostic_Voronoi_ps(p = 2, sd = 0x29, improved = False, sites = False, opr = 'abs(a - b)'):
	imp, sts = 'improved-' if improved else '', '-sites' if sites else ''
	
	fa = './images/Lp-{0}agnostic-Voronoi{1}@{2}.png'.format(imp, sts, sd)
	fp = './images/Voronoi-L{0}@{1}.png'.format(p, sd)

	fav, fpv = Image.open(fa), Image.open(fp); fdv = Image.new('RGB', fpv.size)
	#ImageMath doesn't process RGB images (yet)...
	fdv = Image.merge('RGB', [ImageMath.eval('convert({0}, "L")'.format(opr), a = ipb, b = iqb) \
								for (ipb, iqb) in zip(fpv.split(), fav.split())])
	f = './images/Lp-{0}agnostic-Voronoi-math-L{1}@{2}.png'.format(imp, p, sd)
	fdv.save(f, 'PNG')
	fpv.close(); fdv.close()
	print('Lp agnostic Voronoi math: {0}'.format(f))

	
## Show time off!
start, ssd = TT(), int(RR(0x10000))
c, sd = (int(argv[1]), int(argv[2])) if len(argv) == 3 else (int(argv[1]), ssd) \
									 if len(argv) == 2 else (0x8, ssd) 
## Lp, with p as a reference and q as an illustration
p, q, w = 2.0, 0.5, 0x80

# The reference diagrams...
NXY = lp_Voronoi_diagram(w = w, c = c, sd = sd, p = p)
# ... their Lp-agnostic counterparts
lp_agnostic_Voronoi_diagram(*NXY, w = w, p = p)
lp_agnostic_Voronoi_ps(p = p, sd = sd)

# ... and their improved versions
lp_improved_agnostic_Voronoi_diagram(*NXY, w = w, c = c, p = p, m = 0x3)
lp_agnostic_Voronoi_ps(p = p, sd = sd, improved = True)
lp_agnostic_Voronoi_ps(p = p, sd = sd, improved = True, sites = True, opr = '(a + 2*b)/3')

# An illustration...
_   = lp_Voronoi_diagram(c = c, sd = sd, p = q)
# ... and a summary!
print('Elapsed time = {0}s'.format(round(TT() - start)))